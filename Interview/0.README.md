# Introduction

## To Do List

> 准确了解每个算法的时间复杂度和空间复杂度

- [x] Collection
  - [ ] Array
  - [x] String
  - [ ] Set
  - [ ] Stack / Queue / deque
  - [x] Heap / Priority Queue
  - [ ] 单调栈
- [ ] Sorting
- [ ] quick sort to find the kth min
- [ ] Binary Search
- [ ] Trie
- [x] Tree: traversal / complete / full tree / AVL Tree
- [x] Tree Serialization
- [x] Linked List: fast-slow pointer
- [ ] Two pointer
- [ ] Matrix
- [x] Math
- [ ] Recursion
- [ ] DFS / BFS
- [x] Backtracking
- [ ] Topology Sort
- [ ] Dynamic Programming

- [ ] Bitmap
- [ ] Bit Operation
- [ ] Union Find

------

- [ ] Graph: Minimum Spanning Tree, Shortest Path
- [ ] Maximum Flow: Bipartite Matching, 最小割, 最小路径覆盖
- [ ] Josephus Problem
- [ ] Binary Index Tree
- [ ] Segment Tree
- [ ] KMP
- [ ] Big Data Processing: <http://blog.csdn.net/v_july_v/article/details/7382693>
- [ ] 博弈论
- [ ] String Hash Algorithm, remember 1~3种 
- [ ] Suffix Tree/Array
- [ ] System Design / Object-Oriented Design
- [ ] 继承、pointer、overload, override、memory management、template

## Prepare Stage

1. **Leetcode**：尽量自己做题，除非实在没有思路就看答案。这一遍不要求最优解，仅要求把题过了；
2. **CC189**：把所有题过一遍，可以code，之后参考后面的答案，研究思路（重点），mid+high level经典；
3. **第二遍Leetcode**：每一题找出最优解，甚至多种解法。研究清楚来龙去脉；
4. **第三遍Leetcode**，同时海量吸收算法和题目：
   - 看题目不一定要都写code，主要是接触新题，拓展思路
   - Geek For Geek: <http://www.geeksforgeeks.org/>
   - ACM-ICPC 经典算法，经典题目
   - 编程之美
   - 附件中的《三十七章》
   - 一个神奇的笔记网站：<http://www.csie.ntnu.edu.tw/~u91029/index.html>
5. 看**面经**, 面试前一个半月左右开始，因为面经其实非常多：一亩三分地的面经专版：<http://www.1point3acres.com/bbs/forum-145-1.html>；将你面试时间之前半年到一年的都看一遍
6. **Mock Interview**， 面试前一个月左右开始，As much as you can：和小伙伴一起，体验面试过程，调整心态和提高交流能力。主要练习：1）Whiteboard Coding 2）一边给面试官解说一遍写Code 3) Behavior Questions

## Coding Style

### Python PEP8

### Bug Free

- Anomaly detection
- Boundary detection
- Testing

### Readablility

- Use constant value to store the pre-defined value

## Interview Approach

> Reference: Brain career workshop slides

1. Ask - ALWAYS ask follow-up questions. Almost all technical questions are underspecified. It shows you are curious and do not make assumptions.
2. Suppose - State the givens. For example, "I'm going to code in Python with its Standard Library"
3. Plan - Outline what you plan to do. For example, create placeholder functions then fill them in. 
4. Code - Note this is step 4. You need to this but do not jump right to it.
5. Test - Double check your code with common examples and edge cases.
6. Refactor - Rename variables, erase unnecessary parts, improve performance, and think about scalability...

## Python attention

- `len//2 = int(len/2)`;
- when two integers are **divided**, the result is a floating point;
- **continue assign**: the right hand side variable is not the variable itself, it only a pointer;
- the variable will hold a **reference** to a piece of data and **not the data itself**;
- avoid using `or` in assignment, it dangerous;

## Time Complexity

* $O(1)$ 极少
* $O(logn)$ 几乎都是二分法
* $O(\sqrt n)$ 几乎是分解质因数
* $O(n)$ 高频
* $O(nlogn)$ 一般都可能要排序
* $O(n^2$) 数组，枚举，动态规划
* $O(n^3)$ 数组，枚举，动态规划
* $O(2^n)$ 与组合有关的搜索
* $O(n!)$ 与排列有关的搜索